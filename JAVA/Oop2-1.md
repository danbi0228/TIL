# 객체지향 프로그래밍 2-1 <br>(Object-oriented Programming)

## 1. 상속(inheritance)

### 1.1 상속의 정의와 장점
: **상속**이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고, 코드를 공통적으로 관리할 수 있기 때문에 **코드의 추가 및 변경이 매우 용이**하다.
<br> 코드의 **재사용성을 높이고 코드의 중복을 제거**하여 프로그램의 **생산성과 유지보수**에 크게 기여한다.
<br> **상속** 구현하는 방법 : 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 '**extends**'와 함께 쓴다.

```
class Child extends Parent {
    // ....
}
```
> **조상 클래스** : 부모클래스(parent), 상위클래스(super), 기반클래스(base)
> <br>
> **자손 클래스** : 자식클래스(child), 하위클래스(sub), 파생된 클래스(derived)

```
class Parent {  }
class Child extends Parent {    }
```
- 자손 클래스는 조상 클래스의 모든 멤버를 상속받기 때문에, Child클래스는 Parent클래스의 멤버들을 포함하고 있다.
<br> 만일, Parent클래스에 age라는 정수형 변수를 멤버변수로 추가하면, 자손 클래스는 **조상의 멤버를 모두 상속**받기 때문에 Child클래스에 자동적으로 age 멤버변수가 추가된 것 같은 효과를 얻는다.

```
class Parent {
    int age;
}

class Child extends Parent {    }
```

| 클래스    | 클래스의 멤버 |
|--------|-------|
| Parent | age   |
| Child  | age   |

- Child클래스에 새로운 코드가 추가되어도 조상인 Parent클래스는 아무런 영향도 받지 않는다.
<br> 자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다.

> - **생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.**
> - **자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.**
> - **클래스 간의 관계에서 형제 관계 같은 것은 없다. 부모와 자식의 관계(상속관계)만 존재한다.**

### 1.2 클래스간의 관계 - 포함관계
: 클래스 간의 **포함관계**를 맺어주는 것은 **한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언**하는 것을 뜻한다.


```
class Circle {  // 원
    int x;      // 원점의 x좌표
    int y;      // 원점의 y좌표
    int r;      // 반지름(radius)
}

class Point {   // 좌표상의 점
    int x;      // x좌표
    int y;      // y좌표
}

-------------
class Circle {
    Point c = new Point (); // 원점(int x, int y)
    int r;
}
```

### 1.3 클래스 간의 관계 결정하기
> 원(Circle)은 점(Point)**이다**. - Circle **is a** Point.
> <br>
> 원(Circle)은 점(Point)을 **가지고 있다**. - Circle **has a** Point. (→ 더 자연스럽다.)
> <br><br>
> **상속 관계** : '~은 ~이다.(**is-a**)'
> <br>
> **포함 관계** : '~은 ~을 가지고 있다.(**has-a**)'

: 클래스를 가지고 문장을 만들었을 때 '**~은 ~이다**.' 라는 문장이 성립한다면 서로 **상속관계**를 맺어주고, 
<br> '**~은 ~을 가지고 있다**.'는 문장이 성립한다면 **포함관계**를 맺어준다.
<br> ex) Car클래스와 SportsCar클래스는 'SportCar는 Car이다.'의 문장이 더 옳기 때문에 **상속관계**를 맺어준다.
<br> Card클래스와 Deck클래스는 'Deck은 Card를 가지고 있다.'의 문장이 더 옳기 때문에 **포함관계**를 맺어준다.

### 1.4 단일 상속
: 자바에서는 오직 **단일 상속**만 허용. 둘 이상의 클래스로부터 상속을 받을 수 없다.

### 1.5 Object클래스 - 모든 클래스의 조상
: **Object클래스**는 모든 클래스 상속계층도의 **최상위**에 있는 조상클래스이다.
<br> 다른 클래스로부터 상속받지 않는 모든 클래스들은 컴파일러가 자동적으로 Object클래스로부터 상속받게 함.
<br> **toString()** 이나 **equals(Object o)** 와 같은 메서드를 따로 정의하지 않고도 사용할 수 있는 이유 → 이 메서드들이 Object클래스에 정의된 것들이기 때문.

<br>

## 2. 오버라이딩(overriding)

### 2.1 오버라이딩?
: **조상클래스로부터 상속받은 메서드의 내용을 변경**하는 것.
<br> 상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게 변경해야하는 경우 조상의 메서드를 **오버라이딩**한다.

```
class Point {
    int x;
    int y;
    
    String getLocation() {
        return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;
    
    String getLocation() {      // 오버라이딩
        return "x :" + x + ", y :" + y + ", z :" + z;
    }
}
```

### 2.2 오버라이딩의 조건
- 자손 클래스에서 **오버라이딩**하는 메서드는 조상 클래스의 메서드와
  - **이름이 같아야 한다.**
  - **매개변수가 같아야 한다.**
  - **반환타입이 같아야 한다.**

 → 선언부가 서로 일치해야 한다. 다만, 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경 가능.

1. **접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.**
    - 만일 조상 클래스에 정의된 메서드의 접근 제어자가 protected라면, 오버라이딩 하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야 한다.
   <br>접근 제어자의 접근 범위(넓은 것→좁은 것) : **public, protected, (dafault), private**
2. **조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.**

> **조상 클래스의 메서드를 자손 클래스에서 오버라이딩 할 때**
> <br>
> 1. 접근 제어자를 조상 클래스의 메서드보다 **좁은 범위로 변경할 수 없다**.
> <br>
> 2. **예외**는 조상 클래스의 메서드보다 **많이 선언할 수 없다**.
> <br>
> 3. **인스턴스메서드를 static 메서드로 또는 그 반대로 변경할 수 없다**.

### 2.3 오버로딩 vs 오버라이딩
- **오버로딩(overloading)** : 기존에 없는 **새로운 메서드를 정의**하는 것(new)
- **오버라이딩(overriding)** : **상속받은 메서드의 내용을 변경**하는 것(change, modify)

### 2.4 super
: 자손 클래스에서 조상 클래스로부터 **상속받은 멤버를 참조하는데 사용되는 참조변수**. 상속받은 멤버와 자신의 멤버와 이름이 같을 때 **super**를 붙여서 구분 가능.
<br> static메서드는 인스턴스와 관련이 없다. 그래서 this와 마찬가지로 super도 static메서드에서 사용할 수 없고 **인스턴스메서드에서만 사용할 수 있다.**

### 2.5 super() - 조상 클래스의 생성자
: this()와 마찬가지로 **super() 역시 생성자**이다. 같은 클래스의 다른 생성자를 호출하는데 사용되지만, **super()는 조상 클래스의 생성자를 호출하는데 사용**된다.
> Object클래스를 제외한 모든 클래스의 생성자 첫 줄에 **생성자.this() 또는 super()를 호출**해야 한다. 그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다.

```
Point3D(int x, int y, int z) {
    super();
    this.x = x;
    this.y = y;
    this.z = z;
}
---------------------
Point3D(int x, int y, int z) {
    super(x, y);        // 조상 클래스의 생성자 Point(int x, int y)를 호출
    this.z = z;
}
```
**조상 클래스의 멤버변수는 이처럼 조상의 생성자에 의해 초기화되도록 해야 하는것.**

<br>

## 3. package와 import

### 3.1 패키지(package)
: **클래스의 묶음**. 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리 가능.
<br> **클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.**

- 하나의 소스파일에는 첫번째 문장으로 단 한번의 패키지 선언만을 허용.
- 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
- 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.
- 패키지는 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리이다.


### 3.2 패키지의 선언
: 클래스나 인터페이스의 소스파일(.java)의 맨 위에 다음과 같이 한 줄만 적어주면 된다.
<br> 하나의 소스파일에 단 한 번만 선언 가능. 대소문자 모두 허용하지만, 클래스명과 쉽게 구분하기 위해 소문자로 하는 것이 원칙.
```
package 패키지명;
```

### 3.3 import문
: 클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패미지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명을 생략할 수 있다.
<br> import문의 역할은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것. 
<br> 이클립스 단축키 - 'ctrl + shift + o'

### 3.4 import문의 선언
```
import 패키지명.클래스명;
// 또는
import 패키지명.*;

------------------
import java.util.Calendar;
import java.util.Date;
-----
import java.util.*;
```

### 3.5 static import문
: static import문을 사용하면 static멤버를 호출할 때 클래스 이름 생략 가능.
<br> 특정 클래스의 static멤버를 자주 사용할 때 편리, 코드 간결해짐.
```
import static java.lang.Integer.*;      // Integer클래스의 모든 static메서드
import static java.lang.Math.random;    // 괄호는 붙이지 않는다.
import static java.lang.System.out;     // System.out을 out만으로 참조 가능
--------------

System.out.println(Math.random());
--
out.println(random());
```

<br>

## 4. 제어자(modifier)

### 4.1 제어자란?
: 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여. 크게 접근 제어자와 그 외 제어자로 구분.
<br> **클래스나 멤버변수, 메서드**에 주로 사용, 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능.
- **접근 제어자** : public, protected, dafault, private
- **그 외** : static, abstract, native, transient, synchronized, volatile, strictfp

### 4.2 static - 클래스의, 공통적인
: **static**이 사용될 수 있는 곳 - **멤버변수, 메서드, 초기화 블럭**

| 대상   | 의미                                                                                                 |
|------|----------------------------------------------------------------------------------------------------|
| **멤버변수** | - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다. <br/>- 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.<br/>- 클래스가 메모리에 로드될 때 생성된다. |
| **메서드**  | - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.<br/>- static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.               |

```
class StaticTest {
    static int width = 200;     // 클래스 변수(static변수)
    static int height = 120;    // 클래스 변수(static변수)
    
    static {
        // static변수의 복잡한 초기화 수행
    }
    
    static int max(int a, int b) {  // 클래스 메서드(static메서드)
        return a > b ? a : b;
    }
}
```

### 4.3 final - 마지막의, 변경될 수 없는
: **final**이 사용될 수 있는 곳 - **클래스, 메서드, 멤버변수, 지역변수**
<br> 변수에 사용되면 값을 변경할 수 없는 **상수**가 되며, 메서드에 사용되면 오버라이딩 할 수 없고, 클래스에 사용되면 자손클래스를 정의하지 못함.

| 대상         | 의미                                                                          |
|------------|-----------------------------------------------------------------------------|
| **클래스**    | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.<br/>그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다. |
| **메서드**    | 변경될 수 없는 메서드, fianl로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.                         |
| **멤버변수<br/> 지역변수** | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.                                       |

```
final class FinalTest {             // 조상이 될 수 없는 클래스
    final int MAX_SIZE = 10;        // 값을 변경할 수 없는 멤버변수 (상수)
    
    final void getMaxSize() {       // 오버라이딩할 수 없는 메서드 (변경불가)
        final int LV = MAX_SIZE;    // 값을 변경할 수 없는 지역변수 (상수)
        return MAX_SIZE;
    }
}
```

### 4.4 abstract - 추상의, 미완성의
: **abstract**이 사용될 수 있는 곳 - **클래스, 메서드**
<br> 메서드의 선언부만 작성하고 실제 수행 내용은 구현하지 않는 추상 메서드를 선언하는데 사용.

| 대상     | 의미                                   |
|--------|--------------------------------------|
| **클래스**    | 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.        |
| **메서드**    | 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다. |

```
abstract class AbstractTest {       // 추상 클래스(추상 메서드를 포함한 클래스)
    abstract void move();           // 추상 메서드(구현부가 없는 메서드)
}
```

### 4.5 접근 제어자
: **접근 제어자**가 사용할 수 있는 곳 - **클래스, 멤버변수, 메서드, 생성자**
- **private** : 같은 **클래스** 내에서만 접근 가능
- **dafault** : 같은 **패키지** 내에서만 접근 가능
- **protected** : 같은 **패키지** 내에서, 그리고 **다른 패키지의 자손클래스**에서 접근 가능
- **public** : 접근 제한이 전혀 없다.

(범위가 넓은 쪽) **public > protected > (default) > private** (범위가 좁은 쪽)


| 대상           | 사용가능한 접근 제어자                          |
|--------------|---------------------------------------|
| **클래스**          | public, (default)                     |
| **메서드<br/>멤버변수** | public, protected, (dafault), private |
| **지역변수**         | 없음                                    |


#### 접근 제어자를 이용한 캡슐화
: 클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 **데이터를 보호**하기 위해서.
<br> 데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 외부로부터의 접근을 제한하는 것이 필요한데,
<br> 이것을 **데이터 감추기(data hiding)** 라고 하며, 객체지향개념의 **캡슐화**에 해당한다.



### 4.6 제어자의 조합

| 대상       | 사용 가능한 제어자                         |
|----------|------------------------------------|
| **클래스**  | public, (default), final, abstract |
| **메서드**  | 모든 접근 제어자, final, abstract, static |
| **멤버변수** | 모든 접근 제어자, final, static           |
| **지역변수**  | final                              |

< 제어자를 조합해서 사용할 때 주의해야 할 사항 >
1. **메서드에 static과 abstract를 함께 사용할 수 없다.**
    - static메서드는 몸통이 있는 메서드에서만 사용할 수 있기 때문.
2. **클래스에 abstract와 final을 동시에 사용할 수 없다.**
   - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미, abstract는 상속을 통해서 완성되어야 한다는 의미로 서로 모순되기 때문
3. **abstract메서드의 접근 제어자가 private일 수 없다.**
    - abstract메서드는 자손클래스에서 구현해주어야 하는데 접근제어자가 private이면 자손클래스에서 접근할 수 없다.
4. **메서드에 private과 final을 같이 사용할 필요는 없다.**
    - 접근제어자가 private인 메서드는 오버라이딩 될 수 없기 때문.