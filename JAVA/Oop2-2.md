# 객체지향 프로그래밍 2-2 <br>(Object-oriented Programming)

## 5. 다형성(polymorphism)

### 5.1 다형성이란?
: 객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 구현.
<br> **조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 한다.**

```
class Tv {
    boolean power;      // 전원상태(on/off)
    int channel;        // 채널
    
    void power()        {    power = !power;   }
    void channerlUp()   {      ++channel;      }
    void channerlDown() {      --channel;      }
}

class CaptionTv extends Tv {
    String text;        // 캡션을 보여주기 위한 문자열
    void caption() {  /* */  }
}
```

클래스 Tv와 CaptionTv는 서로 상속관계에 있으며, 이 두 클래스의 인스턴스를 생성하고 사용하기 위해서는 다음과 같이 할 수 있다.
```
Tv t = new Tv();
CaptionTv c = new CaptionTv();

----
Tv t = new CationTv();      // 조상 타입의 참조변수로 자손 인스턴스를 참조
----
CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();
```
둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.
<br> 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다.

> **조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.**
> <br>
> **반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.**


### 5.2 참조변수의 형변환
: 서로 상속관계에 있는 클래스 사이에서 참조변수의 형변환이 가능하다. 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로 형변환만 가능.
<br>
**자손타입 → 조상타입(Up-casting) : 형변환 생략가능<br>
조상타입 → 자손타입(Down-casting) : 형변환 생략불가**

```
CaptionTv c = new CaptionTv();
Tv t = (Tv)c;
```

### 5.3 instanceof연산자
: 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 **instanceof연산자**를 사용. 주로 조건문에 사용되며, **왼쪽에는 참조변수를 오른쪽에는 타입**이 피연산자로 위치한다.
<br>instanceof를 이용한 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

```
void doWork(Car c){
    if (c instacneof FireEngine) {
        FireEngine fe = (FireEngine)c;
        fe.water();
            ...
    } else if (c instanceof Ambulance) {
        Ambulance a = (Ambulance)f;
        a.siren();
        ...
    }
}
```

### 5.4 참조변수와 인스턴스의 연결
: 조상클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때, 조상타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손타입의 참조변수로 자손 인스턴스를 참조하는 경우는 서로 다른 결과를 얻는다.
<br>**멤버변수는 참조변수의 타입에 따라 달라진다.**

#### Vector클래스의 주요 메서드

| 메서드 / 생성자                | 설명                                                                          |
|--------------------------|-----------------------------------------------------------------------------|
| Vector()                 | 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다.<br/>10개 이상의 인스턴스가 저장되면, 자동적으로 크기가 증가된다. |
| boolean add(Object o)    | Vector에 객체를 추가한다. 추가에 성공하면 결과값으로 true, 실패하면 false를 반환.                      |
| boolean remove(Object o) | Vector에 저장되어 있는 객체를 제거한다. 제거에 성공하면 true, 실패하면 false를 반환.                    |
| boolean isEmpty()        | Vector가 비어있는지 검사한다. 비어있으면 true, 비어있지 않으면 false를 반환.                         |
| Object get(int index)    | 지정된 위치(index)의 객체를 반환한다. 반환타입이 Object타입이므로 적절한 타입으로의 형변환이 필요하다.             |
| int size()               | Vector에 저장된 객체의 개수를 반환한다.                                                   |

<br>

## 6. 추상클래스

### 6.1 추상클래스란?
: 미완성 설계도에 비유할 수 있다. 클래스가 미완성이라는 것은 미완성 메서드(추상메서드)를 포함하고 있다는 의미이다.
<br> 추상클래스로 인스턴스는 생성할 수 없다. 추상클래스는 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.
<br> 추상클래스는 '**abstract**'를 붙이기만 하면 된다.
```
abstract class 클래스이름 {
    ...
}
```

### 6.2 추상메서드
: 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨둔 것이 추상메서드이다. 
<br> 메서드를 미완성 상태로 남겨놓는 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상클래스에서는 선언부만을 작성하고, 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성되었는지 알려준다.
<br> **실제 내용은 상속받는 클래스에서 구현하도록 비워 놓는 것**.
```
/* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명 */
abstract 리턴타입 메서드이름();
```

추상클래스로부터 상속받는 자손클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메서드를 모두 구현해주어야 한다.
```
abstract class Player {     // 추상클래스
    abstract void play(int pos);        // 추상메서드
    abstract void stop();               // 추상메서드
}

class AudioPlayer extends Player {
    void play(int pos)  {    /* 내용생략 */   }    // 추상메서드를 구현
    void stop()  {    /* 내용생략 */   }           // 추상메서드를 구현
}

abstract class AbstractPlayer extends Player {
    void play(int pos) {    /* 내용생략 */    }     // 추상메서드를 구현
}
```

### 6.3 추상클래스의 작성
- **추상화** : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업 
- **구체화** : 상속을 통해 클래스를 구현, 확장하는 작업

<br>

## 7. 인터페이스(interface)

### 7.1 인터페이스란?
: 인터페이스는 **일종의 추상클래스**이다. 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.
<br> 오직 **추상메서드와 상수만을 멤버**로 가질 수 있다.
<br> 추상클래스를 '미완성 설계도'라고 한다면, 인터페이스는 구현된 것은 아무것도 없고 밑그림만 그려져 있는 '기본설계도'라 할 수 있다.

### 7.2 인터페이스의 작성
: 인터페이스를 작성하는 것은 클래스를 작성하는 것과 같다. 다만 키워드를 interface를 사용한다. 접근제어자 public 또는 default를 사용할 수 있다.

```
interface 인터페이스이름 {
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}
```

- **모든 멤버변수는 public static final이어야 하며, 이를 생략할 수 있다.**
- **모든 메서드는 public abstract이어야 하며, 이를 생략할 수 있다.**


### 7.3 인터페이스의 상속
: **인터페이스는 인터페이스로부터만 상속**받을 수 있으며, 클래스와는 달리 **다중상속이 가능**하다.

```
interface Movable {
    void move(int x, int y);
}

interface Attackable {
    void attack(unit u);
}

interface Fightable extends Movalbe, Attakable {  } 
```

### 7.4 인터페이스의 구현
: 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 인터페이스도 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다.
<br>인터페이스는 구현한다는 의미의 '**implements**'를 사용한다.

```
class 클래스이름 implements 인터페이스이름 {
    // 인터페이스에 정의된 추상메서드를 구현해야 한다.
}

class Fighter implements Fightable {
    public void move(int x, int y) {  /* 내용생략 */  }
    public void attack(Unit u)     {  /* 내용생략 */  }
}
--------------------
// 상속과 구현을 동시에
class Fightable extends Unit implements Fightable {
    public void move(int x, int y) {  /* 내용생략 */  }
    public void attack(Unit u)     {  /* 내용생략 */  }
}
```

### 7.5 인터페이스를 이용한 다형성
: 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로 형변환도 가능하다.
```
Fightable f = (Fightable)new Fightable();
// 또는
Fightable f = new Fightable();
```

**리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미.**

### 7.6 인터페이스의 장점
- **개발시간을 단축시킬 수 있다.**
- **표준화가 가능하다.**
- **서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.**
- **독립적인 프로그래밍이 가능하다.**

### 7.7 디폴트 메서드와 static 메서드

#### 디폴트 메서드
: 추상메서드의 기본적인 구현을 제공하는 메서드, 추상메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.
<br> 디폴트메서드는 앞에 **default**를 붙이며, 일반 메서드처럼 몸통{}이 있어야 한다. 접근 제어자는 public, 생략 가능
```
interface MyInterface {
    void method();
    default void newMethod{}    // 디폴트메서드
}
```

<br>

## 8. 내부클래스(inner class)

### 8.1 내부클래스란?
: 클래스 내에 선언된 클래스이다.
> 내부클래스의 **장점**
> - **내부클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.**
> - **코드의 복잡성을 줄일 수 있다. (캡슐화)**

### 8.2 내부클래스의 종류와 특징

| 내부클래스      | 특징                                                                                                    |
|------------|-------------------------------------------------------------------------------------------------------|
| **인스턴스 클래스**   | 외부클래스의 멤버변수 선언위치에 선언하며, 외부클래스의 인스턴스멤버처럼 다루어진다.<br/>주로 외부클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언됨.           |
| **static 클래스** | 외부클래스의 멤버변수 선언위치에 선언하며, 외부클래스의 static멤버처럼 다루어진다.<br/>주로 외부크래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언됨. |
| **지역 클래스**     | 외부클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.                                                     |
| **익명 클래스**     | 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)                                                                 |

### 8.3 내부클래스의 제어자와 접근성
: 인스턴스클래스와 static클래스는 외부클래스의 멤버변수(인스턴스변수, 클래스변수)와 같은 위치에 선언되며, 멤버변수와 같은 성질을 갖는다.
<br>따라서 내부클래스가 외부클래스의 멤버와 같이 간주되고, 인스턴스멤버와 static멤버 간의 규칙이 내부 클래스에도 똑같이 적용됨.
<br> 내부클래스도 abstract나 final 같은 제어자를 사용할 수 있고, private, protected와 접근제어자도 사용이 가능하다
<br> 내부클래스 중에서 static클래스만 static멤버를 가질 수 있다. 내부클래스에 static변수를 선언해야 한다면 static클래스로 선언해야 한다.
<br> final과 static이 동시에 붙은 변수는 상수이므로 모든 내부클래스에서 정의가 가능하다.

### 8.4 익명클래스
: 내부클래스들과 달리 이름이 없다. 클래스의 선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용될 수 있고 하나의 객체만을 생성할 수 있는 일회용 클래스.
```
new 조상클래스이름() {
    // 멤버 선언
}

// 또는

new 구현인터페이스이름() {
    // 멤버 선언
}
```

이름이 없기 때문에 생성자도 가질 수 없으며, 오직 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현 가능.
<br> '**외부 클래스명$숫자.class**'의 형식으로 클래스파일명이 결정된다.