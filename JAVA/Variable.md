# 변수(variable)

## 1. 변수란?
> 값을 저장할 수 있는 메모리상의 공간, 단 하나의 값을 저장할 수 있다.
<br>

### 1.1 변수의 선언·초기화
- 변수의 선언 : 저장될 값의 <b>변수타입</b>과 변수에 붙일 <b>변수이름</b>을 지정하여 선언한다. ex) int age;
- 변수의 초기화 : 전에 다른 프로그램에 의해 저장된 알 수 없는 값(쓰레기값)이 남아있을 수 있기 때문에 변수는 반드시 <b>초기화</b> 해야한다.
<br> 변수에 값을 저장할 때는 대입연산자('=')를 이용하여 오른쪽의 값을 왼쪽(변수)에 저장하기 때문에 대입연산자의 왼쪽에 반드시 변수가 와야 한다.


### 1.2 변수의 명명규칙
- 대소문자가 구분되며 길이 제한 없음 → True와 true는 서로 다른 것으로 간주
- 예약어 사용 안됨 → true는 예약어라서 사용할 수 없지만, True는 가능
- 숫자 시작 안됨 → top10은 허용, 7up은 허용되지 않음
- 특수문자는 <b>'_', '$'</b> 만 허용 → $harp은 허용, S#arp은 허용되지 않음

<br>

## 2. 변수의 타입
> 값의 종류는 크게 '문자와 숫자로' 나눌 수 있으며, 숫자는 다시 '정수와 실수'로 나눌 수 있다.
> - 기본형과 참조형
>   * 기본형(primitive type) : 논리형(boolean), 문자형(char), 정수형(byte,short,int,long), 실수형(float, double)
>   * 참조형(reference type) : 객체의 주소를 저장, 8개 기본형을 제외한 나머지 타입 <br>
> 
> - 기본형이 아닌 것들은 모두 참조변수이다.

<br>

### 2.1 기본형(primitive type)
> 기본형에는 모두 8개의 타입(자료형)이 있으며, 크게 논리형, 문자형, 정수형, 실수형으로 구분
- <b>논리형(boolean)</b> : true와 false 중 하나를 값으로 갖음, 조건식과 논리적 계산에 사용, 1byte
- <b>문자형(char)</b> : 문자를 저장하는데 사용, 변수에 하나의 문자만 저장 가능
- <b>정수형(byte, short, int, long)</b> : 정수를 저장하는데 사용, 주로 int 사용
    - byte : -128 ~ 127(-2⁷ ~ 2⁷-1), 8bit, 1byte
    - short : -32,768 ~ 32767(-2¹⁵ ~ 2¹⁵-1), 16bit, 2byte
    - int : -2,147,483,648 ~ 2,147,483,647(-2³¹ ~ 2³¹-1), 32bit, 4byte
    - long : -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807(-2⁶³ ~ 2⁶³-1), 64bit, 8byte
- <b>실수형(float, double)</b> : 실수를 저장하는데 사용, 주로 double 사용
  - float : 1.4E-45 ~ 3.4E38, 32bit, 4byte
  - double : 4.9E-324 ~ 1.8E308, 64bit, 8byte

<br>

### 2.2 상수와 리터럴(constant & literal)
- <b>상수(constant)</b> : 값을 저장할 수 있는 공간이지만 변수와 달리 한 번 값을 저장하면 다른 값으로 변경할 수 없다.
 <br> 변수의 타입 앞에 <b>'final'</b>을 붙여주고, 선언과 동시에 초기화해야 하며 상수의 이름은 모두 대문자로 사용한다.
<br><br>
- <b>리터럴(literal)</b> : 기존에 알고 있던 '상수'와 같은 의미 → 12, 123, 3.14, 'A'와 같은 값들, 그 자체로 값을 의미하는 것

<br>

#### 2.2.1 타입의 불일치
> 리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만 타입이 달라도 저장범위가 <b>넓은 타입에 좁은 타입의 값을 저장하는 것은 허용</b>
> ``` 
> int i = 'A';          // 가능, 문자 'A'의 유니코드인 65가 변수 i에 저장
> long l = 123;         // 가능, int보다 long 타입의 범위가 더 넓다
> double d = 3.14f;     // 가능, float보다 double 타입의 범위가 더 넓다
> 
> int i = 0x123456789;  // 에러, int 타입의 범위를 초과
> float f = 3.14;       // 에러, float 타입보다 double 타입의 범위가 넓다. (3.14는 3.14d에서 d가 생략된 double 타입)
> ```

#### 2.2.2 문자 리터럴과 문자열 리터럴
> - 문자 리터럴 : 'A'와 같이 작은 따옴표로 문자 하나를 감싼 것
> - 문자열 리터럴 : 큰 따옴표로 두 문자 이상을 감싼 것
> <br>
> 
> ```
> char ch = 'J';
> String name = "Java";
> String str = "";                       // 내용이 없는 빈 문자열
> char ch = '';                          // 에러, '' 안에 반드시 하나의 문자가 필요
> char ch = ' ';                         // 가능
> String name = new String("Java");
> ```
>
> 
> - 문자열 + <b>any type</b> → 문자열 + <b>문자열</b> → 문자열
> - <b>any type</b> + 문자열 → <b>문자열</b> + 문자열 → 문자열
> 
> > <b>7</b> + " " → <b>"7"</b> + " " → "7 "
> > <br>
> > " " + <b>7</b> → " " + <b>"7"</b> → " 7"
>  > <br><br>
> > <b>7</b> + "7" → <b>"7"</b> + "7" → "77"
>  > <br><br>
> > <b>7</b> + <b>7</b> + "" → <b>14</b> + "" → <b>"14"</b> + "" → "14"
> > <br>
> > <b>""</b> + <b>7</b> + 7 → "7" + 7 → "7" + "7" → "77"
> > <br><br>
> > <b>true</b> + "" → <b>"true"</b> + "" → "true"

<br>

## 3. 형변환(casting)
> <b>형변환(casting)</b> : 변수 또는 상수 타입을 다른 타입으로 변환하는 것

### 3.1 형변환 방법
> 형변환하고자 하는 변수타 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여준다.
> <br><b>(타입)피연산자</b>
> <br>
> ```
> double d = 85.4;
> int score = (int)d;        // double 타입의 변수 d를 int 타입으로 형변환
> 
> int score = (int)d;
> → int score = (int)85.4;  // 변수 d의 값을 읽어와서 형변환
> → int score = 85;         // 형변환의 결과인 85를 변수 score에 저장한다
> ```

### 3.2 자동 형변환
> 컴파일러가 생략된 형변환을 자동으로 추가
> <br>
> 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.
> ```
> float f = 1234;   // 형변환의 생략. float f = (float)1234;와 같음
> 
> byte b = 1000;    // 에러, byte의 범위(-128~127)를 넘는 값
> 
> int i = 3;
> double d = 1.0 + i;   // double d = 1.0 + (double)i; 에서 형변환이 생략됨
> ```
>
> <br>
> 자동 형변환이 가능한 방향(왼 → 오) <br>
> : byte(1) > short, char(2) > int(4) > long(8) > float(4) > double(8)
> 
> <br>
> 
> 1. boolean을 제외한 나머지 7개 기본형은 <b>서로 형변환이 가능</b>
> 2. <b>기본형과 참조형</b>은 서로 형변환 <b>불가능</b>
> 3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, <b>값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략 가능</b>


